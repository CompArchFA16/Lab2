$date
	Thu Oct 27 22:39:28 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testspi $end
$scope module dut $end
$var wire 1 ! addrWe $end
$var wire 8 " address [7:0] $end
$var wire 1 # bufferin $end
$var wire 1 $ clk $end
$var wire 1 % conditioned $end
$var wire 1 & cs_pin $end
$var wire 1 ' dmWe $end
$var wire 1 ( dummy0 $end
$var wire 1 ) dummy1 $end
$var wire 1 * dummy2 $end
$var wire 1 + dummy3 $end
$var wire 1 , dummy4 $end
$var wire 1 - dummy5 $end
$var wire 1 . falling $end
$var wire 4 / leds [3:0] $end
$var wire 1 0 misoBufe $end
$var wire 1 1 miso_pin $end
$var wire 1 2 mosi_pin $end
$var wire 8 3 parallelDataIn [7:0] $end
$var wire 8 4 parallelDataOut [7:0] $end
$var wire 1 5 rising $end
$var wire 1 6 sclk_pin $end
$var wire 1 7 serialDataOut $end
$var wire 1 8 srWe $end
$scope module ic0 $end
$var wire 1 $ clk $end
$var wire 1 6 noisysignal $end
$var reg 1 9 conditioned $end
$var reg 3 : counter [2:0] $end
$var reg 1 ; negativeedge $end
$var reg 1 < positiveedge $end
$var reg 1 = synchronizer0 $end
$var reg 1 > synchronizer1 $end
$upscope $end
$scope module ic1 $end
$var wire 1 $ clk $end
$var wire 1 2 noisysignal $end
$var reg 1 ? conditioned $end
$var reg 3 @ counter [2:0] $end
$var reg 1 A negativeedge $end
$var reg 1 B positiveedge $end
$var reg 1 C synchronizer0 $end
$var reg 1 D synchronizer1 $end
$upscope $end
$scope module ic2 $end
$var wire 1 $ clk $end
$var wire 1 & noisysignal $end
$var reg 1 E conditioned $end
$var reg 3 F counter [2:0] $end
$var reg 1 G negativeedge $end
$var reg 1 H positiveedge $end
$var reg 1 I synchronizer0 $end
$var reg 1 J synchronizer1 $end
$upscope $end
$scope module sr $end
$var wire 1 $ clk $end
$var wire 8 K parallelDataIn [7:0] $end
$var wire 8 L parallelDataOut [7:0] $end
$var wire 1 . parallelLoad $end
$var wire 1 5 peripheralClkEdge $end
$var wire 1 % serialDataIn $end
$var wire 1 7 serialDataOut $end
$var reg 8 M shiftregistermem [7:0] $end
$upscope $end
$scope module dm $end
$var wire 7 N address [6:0] $end
$var wire 1 $ clk $end
$var wire 8 O dataIn [7:0] $end
$var wire 1 ' writeEnable $end
$var reg 8 P dataOut [7:0] $end
$upscope $end
$scope module fsm $end
$var wire 1 $ clk $end
$var wire 1 % cs $end
$var wire 1 Q rw $end
$var wire 1 5 sclk $end
$var reg 1 R addr $end
$var reg 1 S count $end
$var reg 1 T dm $end
$var reg 1 U misobuff $end
$var reg 1 V sr $end
$var reg 1 W state $end
$upscope $end
$scope module dff $end
$var wire 1 7 d $end
$var wire 1 . enable $end
$var wire 1 $ trigger $end
$var reg 1 X q $end
$upscope $end
$scope module addressLatch $end
$var wire 8 Y d [7:0] $end
$var wire 1 ! enable $end
$var wire 1 $ trigger $end
$var reg 8 Z q [7:0] $end
$upscope $end
$scope module buff $end
$var wire 1 0 enable $end
$var wire 1 # in $end
$var wire 1 1 out $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Z
bx Y
xX
0W
xV
xU
xT
0S
xR
xQ
bx P
bx O
bx N
bx M
bx L
bx K
0J
0I
0H
0G
b0 F
0E
0D
0C
0B
0A
b0 @
0?
0>
0=
0<
0;
b0 :
09
x8
x7
06
05
bx 4
bx 3
x2
x1
x0
bz /
0.
0-
0,
0+
0*
0)
0(
x'
0&
0%
0$
x#
bx "
x!
$end
#10
z1
1=
xC
0V
08
0R
0!
0T
0'
0U
00
16
1$
#13
02
#20
06
0$
#30
xD
0C
1>
16
1$
#33
12
#40
06
0$
#43
02
#50
b1 :
0D
b1 @
16
1$
#53
12
#60
06
0$
#63
02
#70
b0 @
b10 :
16
1$
#80
06
0$
#90
b11 :
16
1$
#100
06
0$
#110
1<
1)
19
1(
b0 :
16
1$
#120
06
0$
#130
0<
0)
16
1$
#140
06
0$
#150
16
1$
#160
06
0$
#170
16
1$
#180
06
0$
#183
